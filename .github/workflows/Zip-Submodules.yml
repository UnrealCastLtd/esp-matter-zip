name: Zip Submodules

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - 'Zipped-Code/submodules.txt'

jobs:
  zip-submodules:
    runs-on: ubuntu-latest
    timeout-minutes: 360  # 6 hours timeout
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.Zipped-Code || secrets.GITHUB_TOKEN }}
        fetch-depth: 0
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'
    
    - name: Setup Git LFS and configuration
      run: |
        # Install and setup Git LFS
        git lfs install
        
        # Configure Git LFS to track zip files
        git lfs track "*.zip"
        git lfs track "Zipped-Code/**/*.zip"
        
        # Add .gitattributes if it doesn't exist or update it
        git add .gitattributes || true
        
        # Setup Git configuration
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Commit .gitattributes if there are changes
        if ! git diff --staged --quiet; then
          git commit -m "Setup Git LFS for zip files [skip ci]"
          git push
        fi

    - name: Parse submodules and create zip files
      run: |
        python3 << 'EOF'
        import re
        import os
        import subprocess
        import json
        import shutil
        import time
        import sys
        from urllib.parse import urlparse

        def parse_submodules(file_path):
            submodules = []
            
            with open(file_path, 'r') as f:
                content = f.read()
            
            # Split by submodule sections
            sections = re.split(r'\[submodule "([^"]+)"\]', content)[1:]  # Skip first empty element
            
            for i in range(0, len(sections), 2):
                if i + 1 < len(sections):
                    name = sections[i]
                    config = sections[i + 1]
                    
                    submodule = {'name': name}
                    
                    # Extract path
                    path_match = re.search(r'path\s*=\s*(.+)', config)
                    if path_match:
                        submodule['path'] = path_match.group(1).strip()
                    
                    # Extract url
                    url_match = re.search(r'url\s*=\s*(.+)', config)
                    if url_match:
                        url = url_match.group(1).strip()
                        # Remove backticks if present
                        url = url.strip('`')
                        submodule['url'] = url
                    
                    # Extract branch
                    branch_match = re.search(r'branch\s*=\s*(.+)', config)
                    if branch_match:
                        submodule['branch'] = branch_match.group(1).strip()
                    
                    # Extract folder
                    folder_match = re.search(r'Folder\s*=\s*(.+)', config)
                    if folder_match:
                        submodule['folder'] = folder_match.group(1).strip()
                    
                    if 'url' in submodule and 'folder' in submodule:
                        submodules.append(submodule)
            
            return submodules

        def get_unique_submodules(submodules):
            # Create a dictionary to track unique combinations of url+branch+folder
            unique_dict = {}
            
            for sub in submodules:
                # Skip relative URLs (like ../openthread.git)
                if sub['url'].startswith('../'):
                    print(f"Skipping relative URL: {sub['url']}")
                    continue
                    
                branch = sub.get('branch', 'main')
                key = f"{sub['url']}#{branch}#{sub['folder']}"
                
                if key not in unique_dict:
                    unique_dict[key] = sub
            
            return list(unique_dict.values())

        def aggressive_cleanup():
            """Ultra-aggressive cleanup with multiple attempts"""
            print("üßπ Performing aggressive cleanup...")
            
            # Kill any git processes that might be hanging
            subprocess.run("pkill -f git || true", shell=True, capture_output=True)
            time.sleep(1)
            
            # Remove all temporary files and directories
            cleanup_commands = [
                "rm -rf temp_clone* || true",
                "rm -rf *.zip || true",
                "rm -rf .git/objects/pack/tmp_* || true",
                "find . -name '*.tmp' -delete || true",
                "find . -name 'core.*' -delete || true"
            ]
            
            for cmd in cleanup_commands:
                subprocess.run(cmd, shell=True, capture_output=True)
                time.sleep(0.2)
            
            # Force garbage collection
            import gc
            gc.collect()
            
            return True

        def check_resources():
            """Check system resources"""
            try:
                # Check disk space
                df_result = subprocess.run(['df', '-h', '.'], capture_output=True, text=True)
                if df_result.returncode == 0:
                    lines = df_result.stdout.strip().split('\n')
                    if len(lines) > 1:
                        fields = lines[1].split()
                        if len(fields) >= 4:
                            print(f"üíæ Disk: {fields[3]} available ({fields[4]} used)")
                
                # Check memory
                free_result = subprocess.run(['free', '-h'], capture_output=True, text=True)
                if free_result.returncode == 0:
                    lines = free_result.stdout.strip().split('\n')
                    if len(lines) > 1:
                        fields = lines[1].split()
                        if len(fields) >= 3:
                            print(f"üß† Memory: {fields[6]} available")
                            
            except Exception as e:
                print(f"Resource check failed: {e}")

        def clone_repository(url, branch, folder, clone_dir):
            """Clone repository with fallback logic"""
            print(f"üì• Cloning {url} (branch: {branch}) to {clone_dir}")
            
            # Clean up any existing directory
            if os.path.exists(clone_dir):
                shutil.rmtree(clone_dir, ignore_errors=True)
            
            # Try with specified branch first
            if branch and branch != 'main':
                try:
                    result = subprocess.run([
                        'git', 'clone', '--depth=1', '--single-branch', 
                        '--branch', branch, url, clone_dir
                    ], timeout=300, capture_output=True, text=True)
                    
                    if result.returncode == 0:
                        print(f"‚úÖ Successfully cloned with branch: {branch}")
                        return True
                    else:
                        print(f"‚ö†Ô∏è Branch {branch} not found, trying fallback...")
                except subprocess.TimeoutExpired:
                    print(f"‚ö†Ô∏è Timeout cloning branch {branch}, trying fallback...")
                except Exception as e:
                    print(f"‚ö†Ô∏è Error cloning branch {branch}: {e}")
            
            # Clean up failed attempt
            if os.path.exists(clone_dir):
                shutil.rmtree(clone_dir, ignore_errors=True)
            
            # Try without branch (gets default branch)
            try:
                result = subprocess.run([
                    'git', 'clone', '--depth=1', url, clone_dir
                ], timeout=300, capture_output=True, text=True)
                
                if result.returncode == 0:
                    print(f"‚úÖ Successfully cloned with default branch")
                    return True
                else:
                    print(f"‚ùå Failed to clone: {result.stderr}")
                    return False
            except subprocess.TimeoutExpired:
                print(f"‚ùå Timeout during clone")
                return False
            except Exception as e:
                print(f"‚ùå Error during clone: {e}")
                return False

        def create_zip(source_dir, zip_path, repo_name):
            """Create zip file from cloned repository"""
            print(f"üì¶ Creating zip: {zip_path}")
            
            # Create directory if it doesn't exist
            os.makedirs(os.path.dirname(zip_path), exist_ok=True)
            
            # Create zip file
            shutil.make_archive(zip_path[:-4], 'zip', source_dir)
            
            # Check if zip was created and get size
            if os.path.exists(zip_path):
                size_mb = os.path.getsize(zip_path) / (1024 * 1024)
                print(f"‚úÖ Zip created: {zip_path} ({size_mb:.2f} MB)")
                return True
            else:
                print(f"‚ùå Failed to create zip: {zip_path}")
                return False

        def commit_and_push_zip(zip_path, repo_name, progress):
            """Commit and push the zip file"""
            try:
                print(f"üì§ Committing and pushing {repo_name}...")
                
                # Add the zip file
                subprocess.run(['git', 'add', zip_path], check=True)
                
                # Commit
                commit_msg = f"Add {repo_name} zip - {progress} [skip ci]"
                subprocess.run(['git', 'commit', '-m', commit_msg], check=True)
                
                # Push
                result = subprocess.run(['git', 'push'], capture_output=True, text=True, timeout=120)
                
                if result.returncode == 0:
                    print(f"‚úÖ Successfully pushed {repo_name}")
                    return True
                else:
                    print(f"‚ö†Ô∏è Push failed: {result.stderr}")
                    return False
                    
            except subprocess.CalledProcessError as e:
                print(f"‚ö†Ô∏è Git operation failed: {e}")
                return False
            except subprocess.TimeoutExpired:
                print(f"‚ö†Ô∏è Push timeout")
                return False
            except Exception as e:
                print(f"‚ö†Ô∏è Unexpected error: {e}")
                return False

        # Main execution
        try:
            print("üöÄ Starting submodule processing...")
            
            # Parse submodules file
            submodules_file = "submodules.txt"
            if not os.path.exists(submodules_file):
                print(f"‚ùå {submodules_file} not found!")
                sys.exit(1)
            
            submodules = parse_submodules(submodules_file)
            unique_submodules = get_unique_submodules(submodules)
            
            total = len(unique_submodules)
            print(f"üìä Found {total} unique submodules to process")
            
            # Initial cleanup and resource check
            aggressive_cleanup()
            check_resources()
            
            successful = 0
            failed = 0
            skipped = 0
            
            for i, submodule in enumerate(unique_submodules, 1):
                print(f"\n{'='*80}")
                print(f"üöÄ Processing {i}/{total}: {submodule['name']}")
                print(f"üìç URL: {submodule['url']}")
                print(f"üìÅ Folder: {submodule['folder']}")
                print(f"üåø Branch: {submodule.get('branch', 'default')}")
                print(f"{'='*80}")
                
                # Extract repo name from URL
                repo_name = submodule['url'].rstrip('/').split('/')[-1]
                if repo_name.endswith('.git'):
                    repo_name = repo_name[:-4]
                
                # Create zip file path
                zip_path = f"Zipped-Code/{submodule['folder']}/{repo_name}.zip"
                
                # Check if zip file already exists
                if os.path.exists(zip_path):
                    print(f"‚è≠Ô∏è SKIPPING: {submodule['name']} - Zip file already exists")
                    print(f"üìÅ Existing file: {zip_path}")
                    skipped += 1
                    continue
                
                # Resource check before processing
                check_resources()
                
                # Create temporary clone directory
                clone_dir = f"temp_clone_{i}_{int(time.time())}"
                
                try:
                    # Clone repository
                    if clone_repository(submodule['url'], submodule.get('branch'), 
                                      submodule['folder'], clone_dir):
                        
                        # Create zip file
                        if create_zip(clone_dir, zip_path, repo_name):
                            
                            # Cleanup clone directory immediately
                            print("üßπ Cleaning up clone directory...")
                            if os.path.exists(clone_dir):
                                shutil.rmtree(clone_dir, ignore_errors=True)
                            
                            # Commit and push
                            progress = f"{i}/{total}"
                            if commit_and_push_zip(zip_path, repo_name, progress):
                                print(f"‚úÖ SUCCESS: {submodule['name']}")
                                successful += 1
                            else:
                                print(f"‚ö†Ô∏è PARTIAL SUCCESS: {submodule['name']} (zip created but not pushed)")
                                successful += 1
                        else:
                            print(f"‚ùå FAILED: {submodule['name']} - Zip creation failed")
                            failed += 1
                    else:
                        print(f"‚ùå FAILED: {submodule['name']} - Clone failed")
                        failed += 1
                        
                except Exception as e:
                    print(f"‚ùå FAILED: {submodule['name']} - {str(e)}")
                    failed += 1
                
                finally:
                    # Always cleanup
                    if os.path.exists(clone_dir):
                        shutil.rmtree(clone_dir, ignore_errors=True)
                    aggressive_cleanup()
                
                # Progress update
                print(f"üìà Progress: {i}/{total} (‚úÖ{successful} ‚è≠Ô∏è{skipped} ‚ùå{failed})")
                
                # Brief pause to prevent overwhelming
                if i < total:
                    time.sleep(1)
            
            # Final summary
            print(f"\n{'='*80}")
            print(f"üéâ PROCESSING COMPLETE!")
            print(f"üìä Total: {total}")
            print(f"‚úÖ Successful: {successful}")
            print(f"‚è≠Ô∏è Skipped (already exists): {skipped}")
            print(f"‚ùå Failed: {failed}")
            print(f"üìà Success Rate: {((successful + skipped)/total)*100:.1f}%")
            print(f"{'='*80}")
            
        except Exception as e:
            print(f"üí• Critical error: {e}")
            sys.exit(1)
        
        finally:
            # Final cleanup
            aggressive_cleanup()
            
        EOF

    - name: Final commit and push
      run: |
        # Add any remaining files that might not have been committed
        git add .
        
        # Check if there are any changes to commit
        if ! git diff --staged --quiet; then
          git commit -m "Final batch of zipped submodules [skip ci]"
          git push
          echo "‚úÖ Final commit pushed successfully"
        else
          echo "‚ÑπÔ∏è No additional changes to commit"
        fi
