name: Zip Submodules

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - 'Zipped-Code/submodules.txt'

jobs:
  zip-submodules:
    runs-on: ubuntu-latest
    timeout-minutes: 360  # 6 hours timeout
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.PAT_TOKEN }}
        fetch-depth: 0
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'
    
    - name: Setup Git LFS and configuration
      run: |
        # Install and setup Git LFS
        git lfs install
        
        # Configure Git LFS to track zip files
        git lfs track "*.zip"
        git lfs track "Zipped-Code/**/*.zip"
        
        # Add .gitattributes if it doesn't exist or update it
        git add .gitattributes || true
        
        # Setup Git configuration
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Commit .gitattributes if there are changes
        if ! git diff --staged --quiet; then
          git commit -m "Setup Git LFS for zip files [skip ci]"
          git push
        fi

    - name: Parse submodules and create zip files
      run: |
        python3 << 'EOF'
        import re
        import os
        import subprocess
        import json
        import shutil
        import time
        import sys
        from urllib.parse import urlparse
        
        def parse_submodules(file_path):
            submodules = []
            
            with open(file_path, 'r') as f:
                content = f.read()
            
            # Split by submodule sections
            sections = re.split(r'\[submodule "([^"]+)"\]', content)[1:]  # Skip first empty element
            
            for i in range(0, len(sections), 2):
                if i + 1 < len(sections):
                    name = sections[i]
                    config = sections[i + 1]
                    
                    submodule = {'name': name}
                    
                    # Extract path
                    path_match = re.search(r'path\s*=\s*(.+)', config)
                    if path_match:
                        submodule['path'] = path_match.group(1).strip()
                    
                    # Extract url
                    url_match = re.search(r'url\s*=\s*(.+)', config)
                    if url_match:
                        url = url_match.group(1).strip()
                        # Remove backticks if present
                        url = url.strip('`')
                        submodule['url'] = url
                    
                    # Extract branch
                    branch_match = re.search(r'branch\s*=\s*(.+)', config)
                    if branch_match:
                        submodule['branch'] = branch_match.group(1).strip()
                    
                    # Extract folder
                    folder_match = re.search(r'Folder\s*=\s*(.+)', config)
                    if folder_match:
                        submodule['folder'] = folder_match.group(1).strip()
                    
                    if 'url' in submodule and 'folder' in submodule:
                        submodules.append(submodule)
            
            return submodules
        
        def get_unique_submodules(submodules):
            # Create a dictionary to track unique combinations of url+branch+folder
            unique_dict = {}
            
            for sub in submodules:
                # Skip relative URLs (like ../openthread.git)
                if sub['url'].startswith('../'):
                    print(f"Skipping relative URL: {sub['url']}")
                    continue
                    
                branch = sub.get('branch', 'main')
                key = f"{sub['url']}#{branch}#{sub['folder']}"
                
                if key not in unique_dict:
                    unique_dict[key] = sub
            
            return list(unique_dict.values())
        
        def aggressive_cleanup():
            """Ultra-aggressive cleanup with multiple attempts"""
            print("üßπ Performing aggressive cleanup...")
            
            # Kill any git processes that might be hanging
            subprocess.run("pkill -f git || true", shell=True, capture_output=True)
            time.sleep(1)
            
            # Remove all temporary files and directories
            cleanup_commands = [
                "rm -rf temp_clone* || true",
                "rm -rf *.zip || true", 
                "rm -rf .git/objects/pack/tmp_* || true",
                "find . -name '*.tmp' -delete || true",
                "find . -name 'core.*' -delete || true"
            ]
            
            for cmd in cleanup_commands:
                subprocess.run(cmd, shell=True, capture_output=True)
                time.sleep(0.2)
            
            # Force garbage collection
            import gc
            gc.collect()
            
            return True
        
        def check_resources():
            """Check system resources"""
            try:
                # Check disk space
                df_result = subprocess.run(['df', '-h', '.'], capture_output=True, text=True)
                if df_result.returncode == 0:
                    lines = df_result.stdout.strip().split('\n')
                    if len(lines) > 1:
                        fields = lines[1].split()
                        if len(fields) >= 4:
                            print(f"üíæ Disk: {fields[3]} available ({fields[4]} used)")
                
                # Check memory
                free_result = subprocess.run(['free', '-h'], capture_output=True, text=True)
                if free_result.returncode == 0:
                    lines = free_result.stdout.strip().split('\n')
                    if len(lines) > 1:
                        fields = lines[1].split()
                        if len(fields) >= 3:
                            print(f"üß† Memory: {fields[6] if len(fields) > 6 else fields[3]} available")
                            
            except Exception as e:
                print(f"Resource check failed: {e}")
        
        def get_default_branch(repo_url):
            """Get the default branch of a repository"""
            try:
                # Use git ls-remote to get the default branch
                result = subprocess.run(
                    ['git', 'ls-remote', '--symref', repo_url, 'HEAD'],
                    capture_output=True, text=True, timeout=30
                )
                
                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')
                    for line in lines:
                        if line.startswith('ref: refs/heads/'):
                            return line.split('/')[-1]
                
                # Fallback: try common default branch names
                common_branches = ['main', 'master', 'develop', 'dev']
                for branch in common_branches:
                    result = subprocess.run(
                        ['git', 'ls-remote', '--heads', repo_url, branch],
                        capture_output=True, text=True, timeout=15
                    )
                    if result.returncode == 0 and result.stdout.strip():
                        return branch
                        
            except Exception as e:
                print(f"   Warning: Could not determine default branch: {e}")
            
            return 'main'  # Final fallback
        
        def clone_with_fallback(repo_url, clone_dir, preferred_branch=None):
            """Clone repository with branch fallback logic"""
            
            # Clean URL (remove backticks)
            clean_url = repo_url.strip('`')
            
            # Try preferred branch first if specified
            if preferred_branch:
                print(f"   Trying preferred branch: {preferred_branch}")
                clone_cmd = [
                    'timeout', '300',
                    'git', 'clone', 
                    '--depth', '1', 
                    '--single-branch', 
                    '--branch', preferred_branch,
                    '--config', 'core.longpaths=true',
                    clean_url, 
                    clone_dir
                ]
                
                result = subprocess.run(clone_cmd, capture_output=True, text=True, timeout=320)
                if result.returncode == 0:
                    print(f"   ‚úÖ Successfully cloned with branch: {preferred_branch}")
                    return True, preferred_branch
                else:
                    print(f"   ‚ö†Ô∏è  Branch '{preferred_branch}' not found, trying fallback...")
            
            # Get default branch and try it
            print(f"   üîç Finding default branch...")
            default_branch = get_default_branch(clean_url)
            print(f"   üìç Default branch detected: {default_branch}")
            
            # Try default branch
            clone_cmd = [
                'timeout', '300',
                'git', 'clone', 
                '--depth', '1', 
                '--single-branch', 
                '--branch', default_branch,
                '--config', 'core.longpaths=true',
                clean_url, 
                clone_dir
            ]
            
            result = subprocess.run(clone_cmd, capture_output=True, text=True, timeout=320)
            if result.returncode == 0:
                print(f"   ‚úÖ Successfully cloned with default branch: {default_branch}")
                return True, default_branch
            
            # Final fallback: clone without specifying branch
            print(f"   üîÑ Trying clone without branch specification...")
            clone_cmd = [
                'timeout', '300',
                'git', 'clone', 
                '--depth', '1',
                '--config', 'core.longpaths=true',
                clean_url, 
                clone_dir
            ]
            
            result = subprocess.run(clone_cmd, capture_output=True, text=True, timeout=320)
            if result.returncode == 0:
                print(f"   ‚úÖ Successfully cloned without branch specification")
                return True, "default"
            else:
                print(f"   ‚ùå All clone attempts failed: {result.stderr}")
                return False, None
        
        def check_file_size(file_path):
            """Check file size and return size in MB"""
            if os.path.exists(file_path):
                size_bytes = os.path.getsize(file_path)
                size_mb = size_bytes / (1024 * 1024)
                return size_mb
            return 0
        
        def commit_and_push_file(zip_path, submodule_name, index, total):
            """Commit and push a single zip file immediately with LFS support"""
            try:
                print(f"üì§ Step 4: Committing and pushing zip file...")
                
                # Check file size
                file_size_mb = check_file_size(zip_path)
                print(f"   üìè File size: {file_size_mb:.2f} MB")
                
                if file_size_mb > 100:
                    print(f"   üì¶ Large file detected ({file_size_mb:.2f} MB), using Git LFS")
                    # Ensure the file is tracked by LFS
                    subprocess.run(['git', 'lfs', 'track', zip_path], capture_output=True)
                
                # Add the specific zip file
                result = subprocess.run(['git', 'add', zip_path], capture_output=True, text=True)
                if result.returncode != 0:
                    print(f"   ‚ö†Ô∏è  Failed to add file: {result.stderr}")
                    return False
                
                # Check if there are changes to commit
                result = subprocess.run(['git', 'diff', '--staged', '--quiet'], capture_output=True)
                if result.returncode == 0:
                    print(f"   ‚ÑπÔ∏è  No changes to commit for {submodule_name}")
                    return True
                
                # Commit with descriptive message
                commit_msg = f"Add {submodule_name} zip file ({index}/{total}) - {file_size_mb:.2f}MB [skip ci]"
                result = subprocess.run(['git', 'commit', '-m', commit_msg], capture_output=True, text=True)
                if result.returncode != 0:
                    print(f"   ‚ö†Ô∏è  Failed to commit: {result.stderr}")
                    return False
                
                # Push to remote with LFS
                print(f"   üöÄ Pushing to remote with PAT token (this may take longer for large files)...")
                result = subprocess.run(['git', 'push'], capture_output=True, text=True, timeout=600)  # 10 min timeout for large files
                if result.returncode != 0:
                    print(f"   ‚ö†Ô∏è  Failed to push: {result.stderr}")
                    return False
                
                print(f"   ‚úÖ Successfully committed and pushed: {submodule_name} ({file_size_mb:.2f} MB)")
                return True
                
            except subprocess.TimeoutExpired:
                print(f"   ‚è∞ Push timeout - large file may still be uploading")
                return False
            except Exception as e:
                print(f"   ‚ùå Error during commit/push: {str(e)}")
                return False
        
        def process_single_submodule(submodule, index, total):
            """Process a single submodule with full isolation"""
            print(f"\n{'='*80}")
            print(f"üöÄ PROCESSING {index}/{total}: {submodule['name']}")
            print(f"üìç URL: {submodule['url']}")
            print(f"üìÅ Folder: {submodule['folder']}")
            if 'branch' in submodule:
                print(f"üåø Preferred Branch: {submodule['branch']}")
            print(f"{'='*80}")
            
            # Pre-process cleanup
            aggressive_cleanup()
            check_resources()
            
            # Extract repo name from URL
            parsed_url = urlparse(submodule['url'].strip('`'))
            repo_name = os.path.basename(parsed_url.path).replace('.git', '')
            
            # Use unique clone directory for this process
            clone_dir = f"temp_clone_{index}_{int(time.time())}"
            preferred_branch = submodule.get('branch')
            
            try:
                print(f"üì• Step 1: Cloning repository...")
                
                # Ensure clean state
                if os.path.exists(clone_dir):
                    shutil.rmtree(clone_dir, ignore_errors=True)
                    time.sleep(0.5)
                
                # Clone with fallback logic
                success, used_branch = clone_with_fallback(
                    submodule['url'], 
                    clone_dir, 
                    preferred_branch
                )
                
                if not success:
                    print(f"‚ùå All clone attempts failed")
                    return False
                
                print(f"‚úÖ Clone successful using branch: {used_branch}")
                
                print(f"üì¶ Step 2: Creating zip file...")
                
                # Create target directory
                target_dir = f"Zipped-Code/{submodule['folder']}"
                os.makedirs(target_dir, exist_ok=True)
                
                # Remove .git directory immediately to save space
                git_dir = os.path.join(clone_dir, '.git')
                if os.path.exists(git_dir):
                    shutil.rmtree(git_dir, ignore_errors=True)
                
                # Create zip file with compression
                zip_filename = f"{repo_name}.zip"
                zip_path = os.path.join(target_dir, zip_filename)
                
                # Use Python's zipfile for better control
                import zipfile
                
                with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED, compresslevel=6) as zipf:
                    for root, dirs, files in os.walk(clone_dir):
                        for file in files:
                            file_path = os.path.join(root, file)
                            arcname = os.path.relpath(file_path, clone_dir)
                            zipf.write(file_path, arcname)
                
                if os.path.exists(zip_path):
                    size = os.path.getsize(zip_path)
                    print(f"‚úÖ Zip created: {zip_path} ({size / (1024*1024):.2f} MB)")
                else:
                    print(f"‚ùå Zip creation failed")
                    return False
                
                print(f"üßπ Step 3: Cleanup temporary files...")
                # Clean up clone directory before committing
                if os.path.exists(clone_dir):
                    shutil.rmtree(clone_dir, ignore_errors=True)
                aggressive_cleanup()
                
                # Commit and push immediately
                commit_success = commit_and_push_file(zip_path, submodule['name'], index, total)
                if not commit_success:
                    print(f"‚ö†Ô∏è  Warning: Failed to commit/push, but zip file was created")
                
                return True
                
            except subprocess.TimeoutExpired:
                print(f"‚è∞ Timeout occurred while processing {submodule['name']}")
                return False
            except Exception as e:
                print(f"‚ùå Error: {str(e)}")
                return False
            finally:
                print(f"üßπ Final cleanup...")
                # Always cleanup, even on failure
                if os.path.exists(clone_dir):
                    shutil.rmtree(clone_dir, ignore_errors=True)
                aggressive_cleanup()
                print(f"‚úÖ Cleanup completed")
        
        # Main execution
        try:
            print("üéØ Starting submodule processing with immediate commits using PAT token...")
            
            # Parse submodules
            submodules = parse_submodules('Zipped-Code/submodules.txt')
            unique_submodules = get_unique_submodules(submodules)
            
            print(f"üìä Found {len(unique_submodules)} unique submodules to process")
            check_resources()
            
            # Initial cleanup
            aggressive_cleanup()
            
            # Process each submodule individually
            successful = 0
            failed = 0
            
            for i, submodule in enumerate(unique_submodules, 1):
                success = process_single_submodule(submodule, i, len(unique_submodules))
                
                if success:
                    successful += 1
                    print(f"‚úÖ SUCCESS: {submodule['name']}")
                else:
                    failed += 1
                    print(f"‚ùå FAILED: {submodule['name']}")
                
                # Progress update
                print(f"üìà Progress: {i}/{len(unique_submodules)} ({successful} successful, {failed} failed)")
                
                # Brief pause between submodules
                if i < len(unique_submodules):
                    print("‚è∏Ô∏è  Brief pause before next submodule...")
                    time.sleep(2)
            
            print(f"\n{'='*80}")
            print(f"üéâ PROCESSING COMPLETE!")
            print(f"‚úÖ Successful: {successful}")
            print(f"‚ùå Failed: {failed}")
            print(f"üìä Total: {len(unique_submodules)}")
            print(f"{'='*80}")
            
            # Final resource check
            check_resources()
            
        except Exception as e:
            print(f"üí• Fatal error: {str(e)}")
            sys.exit(1)
        
        EOF
    
    - name: Final commit and push any remaining files
      run: |
        # Add any remaining files that might not have been committed individually
        git add Zipped-Code/ .gitattributes || true
        
        # Check if there are changes to commit
        if ! git diff --staged --quiet; then
          echo "üì¶ Committing any remaining files..."
          git commit -m "Final commit: Add any remaining zipped submodules [skip ci]"
          git push
        else
          echo "‚úÖ No additional changes to commit - all files were committed individually"
        fi
