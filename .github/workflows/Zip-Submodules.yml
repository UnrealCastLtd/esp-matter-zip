name: Zip Submodules

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - 'Zipped-Code/submodules.txt'

jobs:
  zip-submodules:
    runs-on: ubuntu-latest
    timeout-minutes: 360  # 6 hours timeout
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'
    
    - name: Setup Git LFS and configuration
      run: |
        # Install and setup Git LFS
        git lfs install
        
        # Configure Git LFS to track zip files over 50MB
        git lfs track "*.zip"
        git lfs track "Zipped-Code/**/*.zip"
        
        # Add .gitattributes if it doesn't exist or update it
        git add .gitattributes || true
        
        # Setup Git configuration
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Commit .gitattributes if there are changes
        if ! git diff --staged --quiet; then
          git commit -m "Setup Git LFS for zip files [skip ci]"
          git push origin HEAD
        fi

    - name: Parse submodules and create zip files
      run: |
        import os
        import subprocess
        import zipfile
        import time
        import shutil
        import signal
        import psutil
        from pathlib import Path
        
        def get_system_resources():
            """Get current system resource usage"""
            disk_usage = shutil.disk_usage('/')
            disk_free_gb = disk_usage.free // (1024**3)
            disk_used_percent = (disk_usage.used / disk_usage.total) * 100
            
            memory = psutil.virtual_memory()
            memory_available_gb = memory.available // (1024**3)
            
            return disk_free_gb, disk_used_percent, memory_available_gb
        
        def aggressive_cleanup():
            """Perform aggressive cleanup of temporary files and processes"""
            print("ğŸ§¹ Performing aggressive cleanup...")
            
            # Kill any lingering git processes
            try:
                for proc in psutil.process_iter(['pid', 'name']):
                    if 'git' in proc.info['name'].lower():
                        try:
                            proc.kill()
                        except:
                            pass
            except:
                pass
            
            # Clean up temporary directories
            temp_dirs = ['/tmp', '/var/tmp']
            for temp_dir in temp_dirs:
                if os.path.exists(temp_dir):
                    try:
                        for item in os.listdir(temp_dir):
                            item_path = os.path.join(temp_dir, item)
                            if os.path.isdir(item_path) and ('git' in item.lower() or 'clone' in item.lower()):
                                shutil.rmtree(item_path, ignore_errors=True)
                    except:
                        pass
            
            # Force garbage collection
            try:
                subprocess.run(['python3', '-c', 'import gc; gc.collect()'], 
                             timeout=10, capture_output=True)
            except:
                pass
            
            # Clear system caches if possible
            try:
                subprocess.run(['sync'], timeout=10, capture_output=True)
            except:
                pass
        
        def clone_with_fallback(url, clone_dir, preferred_branch=None, timeout=300):
            """Clone repository with branch fallback logic"""
            print(f"ğŸ“¥ Step 1: Cloning repository...")
            
            # Clean up any existing directory
            if os.path.exists(clone_dir):
                shutil.rmtree(clone_dir, ignore_errors=True)
            
            # Try preferred branch first
            if preferred_branch:
                print(f"    Trying preferred branch: {preferred_branch}")
                try:
                    result = subprocess.run([
                        'git', 'clone', '--depth=1', '--single-branch', 
                        '--branch', preferred_branch, url, clone_dir
                    ], timeout=timeout, capture_output=True, text=True)
                    
                    if result.returncode == 0:
                        print(f"âœ… Clone successful using branch: {preferred_branch}")
                        return preferred_branch
                    else:
                        print(f"    âš ï¸  Branch '{preferred_branch}' not found, trying fallback...")
                except subprocess.TimeoutExpired:
                    print(f"    âš ï¸  Timeout cloning branch '{preferred_branch}', trying fallback...")
                except Exception as e:
                    print(f"    âš ï¸  Error cloning branch '{preferred_branch}': {e}")
            
            # Clean up failed attempt
            if os.path.exists(clone_dir):
                shutil.rmtree(clone_dir, ignore_errors=True)
            
            # Try to find default branch
            print(f"    ğŸ” Finding default branch...")
            try:
                result = subprocess.run([
                    'git', 'ls-remote', '--symref', url, 'HEAD'
                ], timeout=60, capture_output=True, text=True)
                
                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')
                    for line in lines:
                        if line.startswith('ref: refs/heads/'):
                            default_branch = line.split('/')[-1]
                            print(f"    ğŸ“ Default branch detected: {line.split('/')[-1]}")
                            break
                    else:
                        # Fallback to common branch names
                        for branch in ['main', 'master', 'develop']:
                            try:
                                result = subprocess.run([
                                    'git', 'ls-remote', url, f'refs/heads/{branch}'
                                ], timeout=30, capture_output=True, text=True)
                                if result.returncode == 0 and result.stdout.strip():
                                    default_branch = branch
                                    print(f"    ğŸ“ Found branch: {branch}")
                                    break
                            except:
                                continue
                        else:
                            default_branch = None
            except:
                default_branch = None
            
            # Try clone without branch specification (gets default)
            print(f"    ğŸ”„ Trying clone without branch specification...")
            try:
                result = subprocess.run([
                    'git', 'clone', '--depth=1', url, clone_dir
                ], timeout=timeout, capture_output=True, text=True)
                
                if result.returncode == 0:
                    print(f"    âœ… Successfully cloned without branch specification")
                    print(f"âœ… Clone successful using branch: default")
                    return "default"
                else:
                    print(f"    âŒ Failed to clone: {result.stderr}")
                    return None
            except subprocess.TimeoutExpired:
                print(f"    âŒ Timeout during clone")
                return None
            except Exception as e:
                print(f"    âŒ Error during clone: {e}")
                return None
        
        def create_zip_file(source_dir, zip_path):
            """Create zip file from directory"""
            print(f"ğŸ“¦ Step 2: Creating zip file...")
            
            os.makedirs(os.path.dirname(zip_path), exist_ok=True)
            
            with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED, compresslevel=6) as zipf:
                for root, dirs, files in os.walk(source_dir):
                    # Skip .git directories to reduce size
                    if '.git' in dirs:
                        dirs.remove('.git')
                    
                    for file in files:
                        file_path = os.path.join(root, file)
                        arcname = os.path.relpath(file_path, source_dir)
                        try:
                            zipf.write(file_path, arcname)
                        except Exception as e:
                            print(f"    âš ï¸  Warning: Could not add {file_path}: {e}")
            
            # Get file size
            size_mb = os.path.getsize(zip_path) / (1024 * 1024)
            print(f"âœ… Zip created: {zip_path} ({size_mb:.2f} MB)")
            return size_mb
        
        def commit_and_push_file(file_path, repo_name, progress_info):
            """Commit and push a single file"""
            print(f"ğŸ“¤ Step 4: Committing and pushing zip file...")
            
            try:
                # Get file size for logging
                size_mb = os.path.getsize(file_path) / (1024 * 1024)
                print(f"    ğŸ“ File size: {size_mb:.2f} MB")
                
                # Add the file
                subprocess.run(['git', 'add', file_path], check=True, capture_output=True)
                
                # Commit with descriptive message
                commit_msg = f"Add {repo_name} zip file - {progress_info} [skip ci]"
                subprocess.run(['git', 'commit', '-m', commit_msg], check=True, capture_output=True)
                
                # Push with default token
                print(f"    ğŸš€ Pushing to remote...")
                result = subprocess.run(['git', 'push', 'origin', 'HEAD'], 
                                      capture_output=True, text=True, timeout=120)
                
                if result.returncode == 0:
                    print(f"âœ… Successfully pushed {repo_name}")
                    return True
                else:
                    print(f"    âš ï¸  Failed to push: {result.stderr}")
                    return False
                    
            except subprocess.CalledProcessError as e:
                print(f"    âš ï¸  Git operation failed: {e}")
                return False
            except subprocess.TimeoutExpired:
                print(f"    âš ï¸  Push timeout")
                return False
            except Exception as e:
                print(f"    âš ï¸  Unexpected error: {e}")
                return False
        
        # Main processing logic
        submodules_file = "submodules.txt"
        
        if not os.path.exists(submodules_file):
            print(f"âŒ Error: {submodules_file} not found")
            exit(1)
        
        # Read and parse submodules
        with open(submodules_file, 'r') as f:
            lines = [line.strip() for line in f if line.strip() and not line.startswith('#')]
        
        # Extract unique submodules
        unique_submodules = {}
        for line in lines:
            parts = line.split()
            if len(parts) >= 3:
                path = parts[0]
                url = parts[1]
                branch = parts[2] if len(parts) > 2 else None
                
                # Extract repository name from URL
                repo_name = url.rstrip('/').split('/')[-1]
                if repo_name.endswith('.git'):
                    repo_name = repo_name[:-4]
                
                # Use URL as key to avoid duplicates
                if url not in unique_submodules:
                    unique_submodules[url] = {
                        'path': path,
                        'url': url,
                        'branch': branch,
                        'repo_name': repo_name
                    }
        
        total_submodules = len(unique_submodules)
        print(f"ğŸ“Š Found {total_submodules} unique submodules to process")
        
        # Initial resource check
        disk_free, disk_used_pct, memory_available = get_system_resources()
        print(f"ğŸ’¾ Disk: {disk_free}G available ({disk_used_pct:.0f}% used)")
        print(f"ğŸ§  Memory: {memory_available}Gi available")
        
        # Process each submodule
        successful_count = 0
        failed_count = 0
        skipped_count = 0
        
        for i, (url, info) in enumerate(unique_submodules.items(), 1):
            print(f"\n{'='*80}")
            print(f"ğŸš€ PROCESSING {i}/{total_submodules}: {info['path']}")
            print(f"ğŸ“ URL: {info['url']}")
            print(f"ğŸ“ Folder: {info['path']}")
            if info['branch']:
                print(f"ğŸŒ¿ Preferred Branch: {info['branch']}")
            print(f"{'='*80}")
            
            # Create zip file path
            zip_path = f"Zipped-Code/{info['path']}/{info['repo_name']}.zip"
            
            # Check if zip file already exists
            if os.path.exists(zip_path):
                size_mb = os.path.getsize(zip_path) / (1024 * 1024)
                print(f"âœ… SKIPPED: {info['path']} - Zip file already exists ({size_mb:.2f} MB)")
                print(f"ğŸ“¦ Existing file: {zip_path}")
                skipped_count += 1
                continue
            
            # Aggressive cleanup before each submodule
            aggressive_cleanup()
            
            # Resource check
            disk_free, disk_used_pct, memory_available = get_system_resources()
            print(f"ğŸ’¾ Disk: {disk_free}G available ({disk_used_pct:.0f}% used)")
            print(f"ğŸ§  Memory: {memory_available}Gi available")
            
            # Check if we have enough resources
            if disk_free < 2:  # Less than 2GB free
                print(f"âš ï¸  Warning: Low disk space ({disk_free}G), performing extra cleanup...")
                aggressive_cleanup()
                time.sleep(5)
            
            # Create unique temporary directory for this submodule
            temp_clone_dir = f"/tmp/clone_{i}_{int(time.time())}"
            
            try:
                # Clone repository
                branch_used = clone_with_fallback(info['url'], temp_clone_dir, info['branch'])
                
                if branch_used is None:
                    print(f"âŒ FAILED: {info['path']} - Clone failed")
                    failed_count += 1
                    continue
                
                # Create zip file
                size_mb = create_zip_file(temp_clone_dir, zip_path)
                
                # Cleanup temporary clone directory immediately
                print(f"ğŸ§¹ Step 3: Cleanup temporary files...")
                if os.path.exists(temp_clone_dir):
                    shutil.rmtree(temp_clone_dir, ignore_errors=True)
                
                # Additional aggressive cleanup
                aggressive_cleanup()
                
                # Commit and push the zip file
                progress_info = f"Progress {i}/{total_submodules}"
                push_success = commit_and_push_file(zip_path, info['repo_name'], progress_info)
                
                if not push_success:
                    print(f"âš ï¸  Warning: Failed to commit/push, but zip file was created")
                
                print(f"ğŸ§¹ Final cleanup...")
                aggressive_cleanup()
                
                print(f"âœ… SUCCESS: {info['path']}")
                successful_count += 1
                
            except Exception as e:
                print(f"âŒ FAILED: {info['path']} - {str(e)}")
                failed_count += 1
                
                # Cleanup on failure
                if os.path.exists(temp_clone_dir):
                    shutil.rmtree(temp_clone_dir, ignore_errors=True)
                aggressive_cleanup()
            
            # Progress update
            print(f"ğŸ“ˆ Progress: {i}/{total_submodules} ({successful_count} successful, {failed_count} failed, {skipped_count} skipped)")
            
            # Brief pause between submodules to prevent overwhelming the system
            if i < total_submodules:
                print(f"â¸ï¸  Brief pause before next submodule...")
                time.sleep(2)
        
        # Final summary
        print(f"\n{'='*80}")
        print(f"ğŸ‰ PROCESSING COMPLETE!")
        print(f"ğŸ“Š Total: {total_submodules}")
        print(f"âœ… Successful: {successful_count}")
        print(f"â­ï¸  Skipped: {skipped_count}")
        print(f"âŒ Failed: {failed_count}")
        print(f"ğŸ“ˆ Success Rate: {((successful_count + skipped_count)/total_submodules)*100:.1f}%")
        print(f"{'='*80}")
        
        # Final cleanup
        aggressive_cleanup()
        
      shell: python

    - name: Final commit and push
      run: |
        # Add any remaining files
        git add .
        
        # Check if there are any changes to commit
        if ! git diff --staged --quiet; then
          git commit -m "Final batch of zipped submodules [skip ci]"
          git push origin HEAD
          echo "âœ… Final commit pushed successfully"
        else
          echo "â„¹ï¸  No additional changes to commit"
        fi
