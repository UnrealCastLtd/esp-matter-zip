name: Zip Submodules

on:
  push:
    paths:
      - 'submodules.txt'
  workflow_dispatch:

jobs:
  zip-submodules:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0

    - name: Set up Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'

    - name: Setup Git LFS
      run: |
        git lfs install
        git lfs track "*.zip"
        git add .gitattributes
        if ! git diff --cached --quiet; then
          git config --global user.name "github-actions[bot]"
          git config --global user.email "github-actions[bot]@users.noreply.github.com"
          git commit -m "Setup Git LFS for zip files [skip ci]"
          git push origin HEAD
        fi

    - name: Process submodules
      run: |
        python3 << 'EOF'
        import os
        import subprocess
        import shutil
        import zipfile
        import time
        import signal
        import sys
        from collections import defaultdict
        
        def check_resources():
            """Check available system resources"""
            try:
                disk_usage = shutil.disk_usage('.')
                available_gb = disk_usage.free / (1024**3)
                
                print(f"üíæ Available disk space: {available_gb:.1f} GB")
                
                if available_gb < 2:
                    print("‚ö†Ô∏è  Warning: Low disk space!")
                    return False
                return True
            except Exception as e:
                print(f"‚ö†Ô∏è  Could not check resources: {e}")
                return True
        
        def aggressive_cleanup():
            """Perform aggressive cleanup of temporary files and processes"""
            print("üßπ Performing aggressive cleanup...")
            
            # Kill any lingering git processes
            try:
                result = subprocess.run(['pkill', '-f', 'git.*clone'], 
                                      capture_output=True, text=True)
                if result.returncode == 0:
                    print("    üî™ Killed lingering git processes")
            except Exception:
                pass
            
            # Clean up temporary directories
            temp_dirs = ['/tmp', '/var/tmp']
            for temp_dir in temp_dirs:
                if os.path.exists(temp_dir):
                    try:
                        for item in os.listdir(temp_dir):
                            item_path = os.path.join(temp_dir, item)
                            if os.path.isdir(item_path) and ('git' in item.lower() or 'clone' in item.lower()):
                                shutil.rmtree(item_path, ignore_errors=True)
                    except Exception:
                        pass
            
            # Force garbage collection
            try:
                subprocess.run(['python3', '-c', 'import gc; gc.collect()'], 
                             timeout=10, capture_output=True)
            except Exception:
                pass
            
            # Clear system caches if possible
            try:
                subprocess.run(['sync'], timeout=10, capture_output=True)
            except Exception:
                pass
        
        def clone_with_fallback(url, clone_dir, preferred_branch=None, timeout=300):
            """Clone repository with branch fallback logic"""
            print(f"üì• Step 1: Cloning repository...")
            
            # Clean up any existing directory
            if os.path.exists(clone_dir):
                shutil.rmtree(clone_dir, ignore_errors=True)
            
            # Try preferred branch first
            if preferred_branch:
                print(f"    üîÑ Trying preferred branch: {preferred_branch}")
                try:
                    result = subprocess.run([
                        'git', 'clone', '--depth=1', '--branch', preferred_branch, url, clone_dir
                    ], timeout=timeout, capture_output=True, text=True)
                    
                    if result.returncode == 0:
                        print(f"    ‚úÖ Successfully cloned with branch: {preferred_branch}")
                        print(f"‚úÖ Clone successful using branch: {preferred_branch}")
                        return preferred_branch
                    else:
                        print(f"    ‚ùå Failed with preferred branch: {result.stderr}")
                except subprocess.TimeoutExpired:
                    print(f"    ‚ùå Timeout with preferred branch")
                except Exception as e:
                    print(f"    ‚ùå Error with preferred branch: {e}")
            
            # Try to detect default branch
            print(f"    üîç Detecting default branch...")
            default_branch = None
            try:
                result = subprocess.run([
                    'git', 'ls-remote', '--symref', url, 'HEAD'
                ], timeout=30, capture_output=True, text=True)
                
                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')
                    for line in lines:
                        if line.startswith('ref: refs/heads/'):
                            default_branch = line.split('/')[-1]
                            print(f"    üìç Default branch detected: {line.split('/')[-1]}")
                            break
                    else:
                        # Fallback to common branch names
                        for branch in ['main', 'master', 'develop']:
                            try:
                                result = subprocess.run([
                                    'git', 'ls-remote', url, f'refs/heads/{branch}'
                                ], timeout=30, capture_output=True, text=True)
                                if result.returncode == 0 and result.stdout.strip():
                                    default_branch = branch
                                    print(f"    üìç Found branch: {branch}")
                                    break
                            except Exception:
                                continue
                        else:
                            default_branch = None
            except Exception:
                default_branch = None
            
            # Try clone without branch specification (gets default)
            print(f"    üîÑ Trying clone without branch specification...")
            try:
                result = subprocess.run([
                    'git', 'clone', '--depth=1', url, clone_dir
                ], timeout=timeout, capture_output=True, text=True)
                
                if result.returncode == 0:
                    print(f"    ‚úÖ Successfully cloned without branch specification")
                    print(f"‚úÖ Clone successful using branch: default")
                    return "default"
                else:
                    print(f"    ‚ùå Failed to clone: {result.stderr}")
                    return None
            except subprocess.TimeoutExpired:
                print(f"    ‚ùå Timeout during clone")
                return None
            except Exception as e:
                print(f"    ‚ùå Error during clone: {e}")
                return None
        
        def create_zip_file(source_dir, zip_path):
            """Create zip file from directory"""
            print(f"üì¶ Step 2: Creating zip file...")
            
            os.makedirs(os.path.dirname(zip_path), exist_ok=True)
            
            with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED, compresslevel=6) as zipf:
                for root, dirs, files in os.walk(source_dir):
                    # Skip .git directories
                    dirs[:] = [d for d in dirs if d != '.git']
                    
                    for file in files:
                        file_path = os.path.join(root, file)
                        arcname = os.path.relpath(file_path, source_dir)
                        zipf.write(file_path, arcname)
            
            zip_size = os.path.getsize(zip_path) / (1024 * 1024)  # Size in MB
            print(f"    üì¶ Zip file created: {zip_size:.1f} MB")
            print(f"‚úÖ Zip creation successful")
        
        def commit_and_push_file(file_path, commit_message):
            """Commit and push a single file"""
            print(f"üì§ Step 3: Committing and pushing...")
            
            try:
                # Add the specific file
                result = subprocess.run(['git', 'add', file_path], 
                                      timeout=30, capture_output=True, text=True)
                if result.returncode != 0:
                    print(f"    ‚ö†Ô∏è  Git add failed: {result.stderr}")
                    return False
                
                # Check if there are changes to commit
                result = subprocess.run(['git', 'diff', '--cached', '--quiet'], 
                                      timeout=30, capture_output=True)
                if result.returncode == 0:
                    print(f"    ‚ÑπÔ∏è  No changes to commit for {file_path}")
                    return True
                
                # Commit the file
                result = subprocess.run(['git', 'commit', '-m', commit_message], 
                                      timeout=60, capture_output=True, text=True)
                if result.returncode != 0:
                    print(f"    ‚ö†Ô∏è  Git commit failed: {result.stderr}")
                    return False
                
                # Push the commit
                result = subprocess.run(['git', 'push', 'origin', 'HEAD'], 
                                      timeout=120, capture_output=True, text=True)
                if result.returncode == 0:
                    print(f"    ‚úÖ Successfully pushed {file_path}")
                    print(f"‚úÖ Commit and push successful")
                    return True
                else:
                    print(f"    ‚ö†Ô∏è  Git push failed: {result.stderr}")
                    return False
                    
            except subprocess.TimeoutExpired:
                print(f"    ‚ö†Ô∏è  Push timeout")
                return False
            except Exception as e:
                print(f"    ‚ö†Ô∏è  Unexpected error: {e}")
                return False
        
        # Main processing logic
        submodules_file = "Zipped-Code/submodules.txt"
        
 
        if not os.path.exists(submodules_file):
            print(f"‚ùå {submodules_file} not found!")
            print(f"üìç Current working directory: {os.getcwd()}")
            print(f"üìÅ Directory contents:")
            for item in os.listdir('.'):
                print(f"   - {item}")
            if os.path.exists('Zipped-Code'):
                print(f"üìÅ Zipped-Code contents:")
                for item in os.listdir('Zipped-Code'):
                    print(f"   - {item}")
            exit(1)
        
        # Read and parse submodules
        with open(submodules_file, 'r') as f:
            lines = [line.strip() for line in f if line.strip() and not line.startswith('#')]
        
        # Extract unique submodules
        unique_submodules = {}
        for line in lines:
            parts = line.split()
            if len(parts) >= 3:
                path = parts[0]
                url = parts[1]
                branch = parts[2] if len(parts) > 2 else 'main'
                
                # Extract repository name from URL
                repo_name = url.split('/')[-1].replace('.git', '')
                
                # Use path as the key for uniqueness
                if path not in unique_submodules:
                    unique_submodules[path] = {
                        'path': path,
                        'url': url,
                        'branch': branch,
                        'repo_name': repo_name
                    }
        
        print(f"üìã Found {len(unique_submodules)} unique submodules to process")
        
        # Check initial resources
        if not check_resources():
            print("‚ùå Insufficient resources to start processing")
            exit(1)
        
        # Perform initial cleanup
        aggressive_cleanup()
        
        # Process each submodule sequentially
        successful_count = 0
        failed_count = 0
        skipped_count = 0
        
        for i, (path, info) in enumerate(unique_submodules.items(), 1):
            print(f"\n{'='*60}")
            print(f"üîÑ Processing submodule {i}/{len(unique_submodules)}: {info['repo_name']}")
            print(f"üìÇ Path: {info['path']}")
            print(f"üåê URL: {info['url']}")
            print(f"üåø Branch: {info['branch']}")
            print(f"{'='*60}")
            
            # Check resources before each submodule
            if not check_resources():
                print(f"‚ö†Ô∏è  Insufficient resources, performing cleanup...")
                aggressive_cleanup()
                time.sleep(2)
                if not check_resources():
                    print(f"‚ùå Still insufficient resources, skipping remaining submodules")
                    break
            
            # Create zip file path
            zip_path = f"Zipped-Code/{info['path']}/{info['repo_name']}.zip"
            
            # Check if zip file already exists
            if os.path.exists(zip_path):
                print(f"‚è≠Ô∏è  Zip file already exists, skipping: {zip_path}")
                skipped_count += 1
                continue
            
            clone_dir = f"temp_clone_{info['repo_name']}"
            
            try:
                # Step 1: Clone repository
                branch_used = clone_with_fallback(info['url'], clone_dir, info['branch'], timeout=300)
                if not branch_used:
                    print(f"‚ùå Failed to clone {info['repo_name']}")
                    failed_count += 1
                    continue
                
                # Step 2: Create zip file
                create_zip_file(clone_dir, zip_path)
                
                # Step 3: Immediate cleanup of clone directory
                if os.path.exists(clone_dir):
                    shutil.rmtree(clone_dir, ignore_errors=True)
                
                # Step 4: Commit and push this specific zip file
                commit_message = f"Add zipped submodule: {info['repo_name']} from {info['path']} [skip ci]"
                if commit_and_push_file(zip_path, commit_message):
                    successful_count += 1
                    print(f"‚úÖ Successfully processed and pushed: {info['repo_name']}")
                else:
                    print(f"‚ö†Ô∏è  Zip created but push failed for: {info['repo_name']}")
                    failed_count += 1
                
            except Exception as e:
                print(f"‚ùå Error processing {info['repo_name']}: {e}")
                failed_count += 1
            finally:
                # Ensure cleanup
                if os.path.exists(clone_dir):
                    shutil.rmtree(clone_dir, ignore_errors=True)
                
                # Aggressive cleanup after each submodule
                aggressive_cleanup()
                
                # Small delay to prevent overwhelming the system
                time.sleep(1)
        
        # Final commit and push for any remaining files
        print(f"\n{'='*60}")
        print(f"üì§ Final commit and push...")
        print(f"{'='*60}")
        
        try:
            result = subprocess.run(['git', 'add', '.'], timeout=60, capture_output=True, text=True)
            result = subprocess.run(['git', 'diff', '--cached', '--quiet'], timeout=30, capture_output=True)
            
            if result.returncode != 0:  # There are staged changes
                commit_message = f"Final update: processed {successful_count} submodules [skip ci]"
                result = subprocess.run(['git', 'commit', '-m', commit_message], 
                                      timeout=60, capture_output=True, text=True)
                if result.returncode == 0:
                    result = subprocess.run(['git', 'push', 'origin', 'HEAD'], 
                                          timeout=120, capture_output=True, text=True)
                    if result.returncode == 0:
                        print("‚úÖ Final push successful")
                    else:
                        print(f"‚ö†Ô∏è  Final push failed: {result.stderr}")
                else:
                    print(f"‚ö†Ô∏è  Final commit failed: {result.stderr}")
            else:
                print("‚ÑπÔ∏è  No additional changes to commit")
        except Exception as e:
            print(f"‚ö†Ô∏è  Error in final commit/push: {e}")
        
        # Final summary
        print(f"\n{'='*60}")
        print(f"üìä PROCESSING SUMMARY")
        print(f"{'='*60}")
        print(f"‚úÖ Successful: {successful_count}")
        print(f"‚è≠Ô∏è  Skipped: {skipped_count}")
        print(f"‚ùå Failed: {failed_count}")
        print(f"üìã Total: {len(unique_submodules)}")
        print(f"{'='*60}")
        
        if failed_count > 0:
            print(f"‚ö†Ô∏è  Some submodules failed to process. Check the logs above for details.")
            exit(1)
        else:
            print(f"üéâ All submodules processed successfully!")
        EOF
