name: Zip Submodules

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - 'Zipped-Code/submodules.txt'

jobs:
  zip-submodules:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'
    
    - name: Parse submodules and create zip files
      run: |
        python3 << 'EOF'
        import re
        import os
        import subprocess
        import json
        import shutil
        import time
        from urllib.parse import urlparse
        
        def parse_submodules(file_path):
            submodules = []
            current_submodule = {}
            
            with open(file_path, 'r') as f:
                content = f.read()
            
            # Split by submodule sections
            sections = re.split(r'\[submodule "([^"]+)"\]', content)[1:]  # Skip first empty element
            
            for i in range(0, len(sections), 2):
                if i + 1 < len(sections):
                    name = sections[i]
                    config = sections[i + 1]
                    
                    submodule = {'name': name}
                    
                    # Extract path
                    path_match = re.search(r'path\s*=\s*(.+)', config)
                    if path_match:
                        submodule['path'] = path_match.group(1).strip()
                    
                    # Extract url
                    url_match = re.search(r'url\s*=\s*(.+)', config)
                    if url_match:
                        url = url_match.group(1).strip()
                        # Remove backticks if present
                        url = url.strip('`')
                        submodule['url'] = url
                    
                    # Extract branch
                    branch_match = re.search(r'branch\s*=\s*(.+)', config)
                    if branch_match:
                        submodule['branch'] = branch_match.group(1).strip()
                    
                    # Extract folder
                    folder_match = re.search(r'Folder\s*=\s*(.+)', config)
                    if folder_match:
                        submodule['folder'] = folder_match.group(1).strip()
                    
                    if 'url' in submodule and 'folder' in submodule:
                        submodules.append(submodule)
            
            return submodules
        
        def get_unique_submodules(submodules):
            # Create a dictionary to track unique combinations of url+branch+folder
            unique_dict = {}
            
            for sub in submodules:
                # Skip relative URLs (like ../openthread.git)
                if sub['url'].startswith('../'):
                    print(f"Skipping relative URL: {sub['url']}")
                    continue
                    
                branch = sub.get('branch', 'main')
                key = f"{sub['url']}#{branch}#{sub['folder']}"
                
                if key not in unique_dict:
                    unique_dict[key] = sub
            
            return list(unique_dict.values())
        
        def force_cleanup_temp_files():
            """Aggressively clean up any temporary files and directories"""
            print("🧹 Performing cleanup...")
            
            # List of patterns to clean up
            cleanup_patterns = ['temp_clone*', '*.zip']
            
            for pattern in cleanup_patterns:
                # Use shell commands for more reliable cleanup
                subprocess.run(f"rm -rf {pattern}", shell=True, capture_output=True)
            
            # Specifically target temp_clone directory
            if os.path.exists('temp_clone'):
                print("   Removing temp_clone directory...")
                try:
                    # Try Python removal first
                    shutil.rmtree('temp_clone', ignore_errors=True)
                    time.sleep(0.5)  # Give it a moment
                    
                    # If it still exists, use shell command
                    if os.path.exists('temp_clone'):
                        subprocess.run('rm -rf temp_clone', shell=True, capture_output=True)
                        time.sleep(0.5)
                        
                    # Final check
                    if os.path.exists('temp_clone'):
                        print("   ⚠️  Warning: temp_clone still exists, trying sudo...")
                        subprocess.run('sudo rm -rf temp_clone', shell=True, capture_output=True)
                        
                except Exception as e:
                    print(f"   Error during cleanup: {e}")
            
            # Verify cleanup
            if os.path.exists('temp_clone'):
                print("   ❌ Failed to remove temp_clone")
                return False
            else:
                print("   ✅ Cleanup successful")
                return True
        
        def check_disk_space():
            """Check available disk space"""
            result = subprocess.run(['df', '-h', '.'], capture_output=True, text=True)
            print(f"💾 Disk space: {result.stdout.split()[10]} available")
        
        # Parse submodules from the correct path
        submodules = parse_submodules('Zipped-Code/submodules.txt')
        unique_submodules = get_unique_submodules(submodules)
        
        print(f"Found {len(unique_submodules)} unique submodules to process")
        check_disk_space()
        
        # Initial cleanup
        force_cleanup_temp_files()
        
        # Process each unique submodule ONE BY ONE
        for i, submodule in enumerate(unique_submodules):
            print(f"\n{'='*60}")
            print(f"Processing {i+1}/{len(unique_submodules)}: {submodule['name']}")
            print(f"URL: {submodule['url']}")
            print(f"Folder: {submodule['folder']}")
            print(f"{'='*60}")
            
            # Force cleanup before each iteration
            cleanup_success = force_cleanup_temp_files()
            if not cleanup_success:
                print("❌ Cleanup failed, skipping this submodule")
                continue
            
            # Extract repo name from URL
            parsed_url = urlparse(submodule['url'])
            repo_name = os.path.basename(parsed_url.path).replace('.git', '')
            
            # Use a simple clone directory name
            clone_dir = "temp_clone"
            branch = submodule.get('branch', 'main')
            
            try:
                print(f"Step 1: Cloning repository...")
                
                # Double-check that clone directory doesn't exist
                if os.path.exists(clone_dir):
                    print(f"   ⚠️  {clone_dir} still exists, forcing removal...")
                    subprocess.run(f'rm -rf {clone_dir}', shell=True)
                    time.sleep(1)
                
                # Clone with specific branch if specified
                if 'branch' in submodule:
                    clone_cmd = f"git clone --depth 1 --single-branch --branch {branch} '{submodule['url']}' {clone_dir}"
                else:
                    clone_cmd = f"git clone --depth 1 --single-branch '{submodule['url']}' {clone_dir}"
                
                print(f"   Running: {clone_cmd}")
                result = subprocess.run(clone_cmd, shell=True, capture_output=True, text=True)
                if result.returncode != 0:
                    print(f"❌ Failed to clone {submodule['url']}: {result.stderr}")
                    force_cleanup_temp_files()
                    continue
                
                print(f"Step 2: Creating target directory structure...")
                # Create the target directory structure
                target_dir = f"Zipped-Code/{submodule['folder']}"
                os.makedirs(target_dir, exist_ok=True)
                
                print(f"Step 3: Creating zip file...")
                # Create zip file
                zip_filename = f"{repo_name}.zip"
                zip_path = os.path.join(target_dir, zip_filename)
                
                # Remove .git directory to save space before zipping
                git_dir = os.path.join(clone_dir, '.git')
                if os.path.exists(git_dir):
                    shutil.rmtree(git_dir, ignore_errors=True)
                
                # Zip the cloned repository
                zip_cmd = f"cd {clone_dir} && zip -r ../{zip_path} ."
                result = subprocess.run(zip_cmd, shell=True, capture_output=True, text=True)
                
                if result.returncode == 0:
                    print(f"✅ Successfully created: {zip_path}")
                    # Get file size
                    if os.path.exists(zip_path):
                        size = os.path.getsize(zip_path)
                        print(f"   File size: {size / (1024*1024):.2f} MB")
                else:
                    print(f"❌ Failed to create zip: {result.stderr}")
                
                print(f"Step 4: Cleaning up temporary files...")
                # Immediately clean up clone directory and any temp files
                force_cleanup_temp_files()
                
                print(f"✅ Completed processing {submodule['name']}")
                check_disk_space()
                
            except Exception as e:
                print(f"❌ Error processing {submodule['name']}: {str(e)}")
                # Clean up on error
                force_cleanup_temp_files()
                continue
        
        print(f"\n{'='*60}")
        print("🎉 Completed processing all submodules")
        print(f"{'='*60}")
        check_disk_space()
        EOF
    
    - name: Commit and push zipped files
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Add all new zip files
        git add Zipped-Code/
        
        # Check if there are changes to commit
        if git diff --staged --quiet; then
          echo "No changes to commit"
        else
          git commit -m "Add zipped submodules [skip ci]"
          git push
        fi
