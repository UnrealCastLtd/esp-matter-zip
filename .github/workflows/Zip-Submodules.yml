name: Zip Submodules

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - 'submodules.txt'

jobs:
  zip-submodules:
    runs-on: ubuntu-latest
    timeout-minutes: 360  # 6 hours timeout
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'
    
    - name: Setup Git LFS and configuration
      run: |
        # Install and setup Git LFS
        git lfs install
        
        # Configure Git LFS to track zip files over 50MB
        git lfs track "*.zip"
        git lfs track "Zipped-Code/**/*.zip"
        
        # Add .gitattributes if it doesn't exist or update it
        git add .gitattributes || true
        
        # Setup Git configuration
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Commit .gitattributes if there are changes
        if ! git diff --staged --quiet; then
          git commit -m "Setup Git LFS for zip files [skip ci]"
          git push origin HEAD
        fi

    - name: Parse submodules and create zip files
      run: |
        import os
        import subprocess
        import zipfile
        import time
        import shutil
        import signal
        from pathlib import Path
        
        def get_system_resources():
            """Get current system resource usage"""
            disk_usage = shutil.disk_usage('/')
            disk_free_gb = disk_usage.free // (1024**3)
            disk_used_percent = (disk_usage.used / disk_usage.total) * 100
            
            return disk_free_gb, disk_used_percent
        
        def aggressive_cleanup():
            """Perform aggressive cleanup of temporary files and processes"""
            print("üßπ Performing aggressive cleanup...")
            
            # Clean up temporary directories
            temp_dirs = ['/tmp', '/var/tmp']
            for temp_dir in temp_dirs:
                if os.path.exists(temp_dir):
                    try:
                        for item in os.listdir(temp_dir):
                            item_path = os.path.join(temp_dir, item)
                            if os.path.isdir(item_path) and ('git' in item.lower() or 'clone' in item.lower()):
                                shutil.rmtree(item_path, ignore_errors=True)
                    except:
                        pass
            
            # Force garbage collection
            try:
                subprocess.run(['python3', '-c', 'import gc; gc.collect()'], 
                             timeout=10, capture_output=True)
            except:
                pass
            
            # Clear system caches if possible
            try:
                subprocess.run(['sync'], timeout=10, capture_output=True)
            except:
                pass
        
        def clone_with_fallback(url, clone_dir, preferred_branch=None, timeout=300):
            """Clone repository with branch fallback logic"""
            print(f"üì• Step 1: Cloning repository...")
            
            # Clean up any existing directory
            if os.path.exists(clone_dir):
                shutil.rmtree(clone_dir, ignore_errors=True)
            
            # Try preferred branch first
            if preferred_branch:
                print(f"    Trying preferred branch: {preferred_branch}")
                try:
                    result = subprocess.run([
                        'git', 'clone', '--depth=1', '--single-branch', 
                        '--branch', preferred_branch, url, clone_dir
                    ], timeout=timeout, capture_output=True, text=True)
                    
                    if result.returncode == 0:
                        print(f"‚úÖ Clone successful using branch: {preferred_branch}")
                        return preferred_branch
                    else:
                        print(f"    ‚ö†Ô∏è  Branch '{preferred_branch}' not found, trying fallback...")
                except subprocess.TimeoutExpired:
                    print(f"    ‚ö†Ô∏è  Timeout cloning branch '{preferred_branch}', trying fallback...")
                except Exception as e:
                    print(f"    ‚ö†Ô∏è  Error cloning branch '{preferred_branch}': {e}")
            
            # Clean up failed attempt
            if os.path.exists(clone_dir):
                shutil.rmtree(clone_dir, ignore_errors=True)
            
            # Try to find default branch
            print(f"    üîç Finding default branch...")
            try:
                result = subprocess.run([
                    'git', 'ls-remote', '--symref', url, 'HEAD'
                ], timeout=60, capture_output=True, text=True)
                
                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')
                    for line in lines:
                        if line.startswith('ref: refs/heads/'):
                            default_branch = line.split('/')[-1]
                            print(f"    üìç Default branch detected: {line.split('/')[-1]}")
                            break
                    else:
                        # Fallback to common branch names
                        for branch in ['main', 'master', 'develop']:
                            try:
                                result = subprocess.run([
                                    'git', 'ls-remote', url, f'refs/heads/{branch}'
                                ], timeout=30, capture_output=True, text=True)
                                if result.returncode == 0 and result.stdout.strip():
                                    default_branch = branch
                                    print(f"    üìç Found branch: {branch}")
                                    break
                            except:
                                continue
                        else:
                            default_branch = None
            except:
                default_branch = None
            
            # Try clone without branch specification (gets default)
            print(f"    üîÑ Trying clone without branch specification...")
            try:
                result = subprocess.run([
                    'git', 'clone', '--depth=1', url, clone_dir
                ], timeout=timeout, capture_output=True, text=True)
                
                if result.returncode == 0:
                    print(f"    ‚úÖ Successfully cloned without branch specification")
                    print(f"‚úÖ Clone successful using branch: default")
                    return "default"
                else:
                    print(f"    ‚ùå Failed to clone: {result.stderr}")
                    return None
            except subprocess.TimeoutExpired:
                print(f"    ‚ùå Timeout during clone")
                return None
            except Exception as e:
                print(f"    ‚ùå Error during clone: {e}")
                return None
        
        def create_zip_file(source_dir, zip_path):
            """Create zip file from directory"""
            print(f"üì¶ Step 2: Creating zip file...")
            
            os.makedirs(os.path.dirname(zip_path), exist_ok=True)
            
            with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED, compresslevel=6) as zipf:
                for root, dirs, files in os.walk(source_dir):
                    # Skip .git directories to reduce size
                    if '.git' in dirs:
                        dirs.remove('.git')
                    
                    for file in files:
                        file_path = os.path.join(root, file)
                        arcname = os.path.relpath(file_path, source_dir)
                        try:
                            zipf.write(file_path, arcname)
                        except Exception as e:
                            print(f"    ‚ö†Ô∏è  Warning: Could not add {file_path}: {e}")
            
            # Get file size
            size_mb = os.path.getsize(zip_path) / (1024 * 1024)
            print(f"‚úÖ Zip created: {zip_path} ({size_mb:.2f} MB)")
            return size_mb
        
        def commit_and_push_file(file_path, repo_name, progress_info):
            """Commit and push a single file"""
            print(f"üì§ Step 4: Committing and pushing zip file...")
            
            try:
                # Get file size for logging
                size_mb = os.path.getsize(file_path) / (1024 * 1024)
                print(f"    üìè File size: {size_mb:.2f} MB")
                
                # Add the file
                subprocess.run(['git', 'add', file_path], check=True, capture_output=True)
                
                # Commit with descriptive message
                commit_msg = f"Add {repo_name} zip file - {progress_info} [skip ci]"
                subprocess.run(['git', 'commit', '-m', commit_msg], check=True, capture_output=True)
                
                # Push with default token
                print(f"    üöÄ Pushing to remote...")
                result = subprocess.run(['git', 'push', 'origin', 'HEAD'], 
                                      capture_output=True, text=True, timeout=120)
                
                if result.returncode == 0:
                    print(f"‚úÖ Successfully pushed {repo_name}")
                    return True
                else:
                    print(f"    ‚ö†Ô∏è  Failed to push: {result.stderr}")
                    return False
                    
            except subprocess.CalledProcessError as e:
                print(f"    ‚ö†Ô∏è  Git operation failed: {e}")
                return False
            except subprocess.TimeoutExpired:
                print(f"    ‚ö†Ô∏è  Push timeout")
                return False
            except Exception as e:
                print(f"    ‚ö†Ô∏è  Unexpected error: {e}")
                return False
        
        def parse_gitmodules_format(file_path):
            """Parse .gitmodules format file and extract submodule information"""
            submodules = {}
            current_submodule = None
            
            with open(file_path, 'r', encoding='utf-8') as f:
                for line_num, line in enumerate(f, 1):
                    line = line.strip()
                    
                    # Skip empty lines and comments
                    if not line or line.startswith('#'):
                        continue
                    
                    # Check for submodule section header
                    if line.startswith('[submodule '):
                        # Extract submodule name from [submodule "name"]
                        try:
                            start_quote = line.index('"') + 1
                            end_quote = line.rindex('"')
                            current_submodule = line[start_quote:end_quote]
                            submodules[current_submodule] = {}
                        except ValueError:
                            print(f"    ‚ö†Ô∏è  Warning: Invalid submodule header at line {line_num}: {line}")
                            current_submodule = None
                        continue
                    
                    # Parse key = value pairs
                    if current_submodule and '=' in line:
                        try:
                            key, value = line.split('=', 1)
                            key = key.strip()
                            value = value.strip()
                            submodules[current_submodule][key] = value
                        except ValueError:
                            print(f"    ‚ö†Ô∏è  Warning: Invalid key-value pair at line {line_num}: {line}")
            
            return submodules
        
        # Main processing logic
        submodules_file = "submodules.txt"
        
        if not os.path.exists(submodules_file):
            print(f"‚ùå Error: {submodules_file} not found")
            print("üìÅ Current directory contents:")
            for item in os.listdir('.'):
                print(f"    {item}")
            exit(1)
        
        # Parse submodules using .gitmodules format
        print(f"üìñ Parsing {submodules_file}...")
        parsed_submodules = parse_gitmodules_format(submodules_file)
        print(f"üìä Parsed {len(parsed_submodules)} submodule entries")
        
        # Extract unique HTTP/HTTPS submodules
        unique_submodules = {}
        skipped_count = 0
        
        for name, config in parsed_submodules.items():
            url = config.get('url', '')
            path = config.get('path', '')
            branch = config.get('branch', None)
            folder = config.get('Folder', '')
            
            # Skip if no URL or path
            if not url or not path:
                print(f"    ‚ö†Ô∏è  Skipping {name}: missing URL or path")
                skipped_count += 1
                continue
            
            # Skip relative URLs (like ../openthread.git)
            if url.startswith('../') or url.startswith('./') or not url.startswith(('http://', 'https://')):
                print(f"    ‚ö†Ô∏è  Skipping {name}: relative or non-HTTP URL: {url}")
                skipped_count += 1
                continue
            
            # Extract repository name from URL
            repo_name = url.rstrip('/').split('/')[-1]
            if repo_name.endswith('.git'):
                repo_name = repo_name[:-4]
            
            # Use URL as key to avoid duplicates
            if url not in unique_submodules:
                unique_submodules[url] = {
                    'name': name,
                    'path': path,
                    'url': url,
                    'branch': branch,
                    'folder': folder,
                    'repo_name': repo_name
                }
        
        total_submodules = len(unique_submodules)
        print(f"üìä Found {total_submodules} unique HTTP/HTTPS submodules to process")
        print(f"üìä Skipped {skipped_count} submodules (relative URLs or missing data)")
        
        # Check if zip already exists and skip if it does
        processed_count = 0
        skipped_existing = 0
        
        # Initial resource check
        disk_free, disk_used_pct = get_system_resources()
        print(f"üíæ Disk: {disk_free}G available ({disk_used_pct:.0f}% used)")
        
        # Process each submodule
        successful_count = 0
        failed_count = 0
        
        for i, (url, submodule) in enumerate(unique_submodules.items(), 1):
            repo_name = submodule['repo_name']
            branch = submodule['branch']
            folder = submodule['folder']
            
            progress_info = f"({i}/{total_submodules})"
            print(f"\nüîÑ Processing {repo_name} {progress_info}")
            print(f"    üìç URL: {url}")
            if branch:
                print(f"    üåø Branch: {branch}")
            if folder:
                print(f"    üìÅ Target folder: {folder}")
            
            # Determine zip file path
            if folder:
                zip_path = f"Zipped-Code/{folder}/{repo_name}.zip"
            else:
                zip_path = f"Zipped-Code/{repo_name}.zip"
            
            # Check if zip already exists
            if os.path.exists(zip_path):
                print(f"    ‚úÖ Zip already exists: {zip_path}")
                skipped_existing += 1
                continue
            
            clone_dir = f"temp_clone_{repo_name}_{int(time.time())}"
            
            try:
                # Step 1: Clone repository
                used_branch = clone_with_fallback(url, clone_dir, branch)
                if not used_branch:
                    print(f"‚ùå Failed to clone {repo_name}")
                    failed_count += 1
                    continue
                
                # Step 2: Create zip file
                size_mb = create_zip_file(clone_dir, zip_path)
                
                # Step 3: Clean up clone directory immediately
                print(f"üßπ Step 3: Cleaning up clone directory...")
                if os.path.exists(clone_dir):
                    shutil.rmtree(clone_dir, ignore_errors=True)
                
                # Step 4: Commit and push immediately
                if commit_and_push_file(zip_path, repo_name, progress_info):
                    successful_count += 1
                    print(f"‚úÖ Successfully processed {repo_name} ({size_mb:.2f} MB)")
                else:
                    failed_count += 1
                    print(f"‚ùå Failed to push {repo_name}")
                
                processed_count += 1
                
                # Resource management
                if processed_count % 5 == 0:
                    aggressive_cleanup()
                    disk_free, disk_used_pct = get_system_resources()
                    print(f"üíæ Resources after {processed_count} processed: {disk_free}G free ({disk_used_pct:.0f}% used)")
                
                # Stop if disk space is critically low
                if disk_free < 2:
                    print(f"‚ö†Ô∏è  Critical: Only {disk_free}G disk space remaining. Stopping processing.")
                    break
                
            except Exception as e:
                print(f"‚ùå Error processing {repo_name}: {e}")
                failed_count += 1
                
                # Clean up on error
                if os.path.exists(clone_dir):
                    shutil.rmtree(clone_dir, ignore_errors=True)
                if os.path.exists(zip_path):
                    os.remove(zip_path)
            
            # Small delay between operations
            time.sleep(1)
        
        # Final cleanup
        aggressive_cleanup()
        
        # Summary
        print(f"\nüìä Processing Summary:")
        print(f"    ‚úÖ Successful: {successful_count}")
        print(f"    ‚è≠Ô∏è  Skipped (existing): {skipped_existing}")
        print(f"    ‚ùå Failed: {failed_count}")
        print(f"    üìä Total processed: {processed_count}")
        print(f"    üìä Total unique submodules: {total_submodules}")
        
        if failed_count > 0:
            exit(1)
      shell: python
