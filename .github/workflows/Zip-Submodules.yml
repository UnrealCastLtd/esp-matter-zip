name: Zip Submodules

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - 'Zipped-Code/submodules.txt'

jobs:
  zip-submodules:
    runs-on: ubuntu-latest
    timeout-minutes: 360  # 6 hours timeout
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'
    
    - name: Parse submodules and create zip files
      run: |
        python3 << 'EOF'
        import re
        import os
        import subprocess
        import json
        import shutil
        import time
        import sys
        from urllib.parse import urlparse
        
        def parse_submodules(file_path):
            submodules = []
            
            with open(file_path, 'r') as f:
                content = f.read()
            
            # Split by submodule sections
            sections = re.split(r'\[submodule "([^"]+)"\]', content)[1:]  # Skip first empty element
            
            for i in range(0, len(sections), 2):
                if i + 1 < len(sections):
                    name = sections[i]
                    config = sections[i + 1]
                    
                    submodule = {'name': name}
                    
                    # Extract path
                    path_match = re.search(r'path\s*=\s*(.+)', config)
                    if path_match:
                        submodule['path'] = path_match.group(1).strip()
                    
                    # Extract url
                    url_match = re.search(r'url\s*=\s*(.+)', config)
                    if url_match:
                        url = url_match.group(1).strip()
                        # Remove backticks if present
                        url = url.strip('`')
                        submodule['url'] = url
                    
                    # Extract branch
                    branch_match = re.search(r'branch\s*=\s*(.+)', config)
                    if branch_match:
                        submodule['branch'] = branch_match.group(1).strip()
                    
                    # Extract folder
                    folder_match = re.search(r'Folder\s*=\s*(.+)', config)
                    if folder_match:
                        submodule['folder'] = folder_match.group(1).strip()
                    
                    if 'url' in submodule and 'folder' in submodule:
                        submodules.append(submodule)
            
            return submodules
        
        def get_unique_submodules(submodules):
            # Create a dictionary to track unique combinations of url+branch+folder
            unique_dict = {}
            
            for sub in submodules:
                # Skip relative URLs (like ../openthread.git)
                if sub['url'].startswith('../'):
                    print(f"Skipping relative URL: {sub['url']}")
                    continue
                    
                branch = sub.get('branch', 'main')
                key = f"{sub['url']}#{branch}#{sub['folder']}"
                
                if key not in unique_dict:
                    unique_dict[key] = sub
            
            return list(unique_dict.values())
        
        def aggressive_cleanup():
            """Ultra-aggressive cleanup with multiple attempts"""
            print("üßπ Performing aggressive cleanup...")
            
            # Kill any git processes that might be hanging
            subprocess.run("pkill -f git || true", shell=True, capture_output=True)
            time.sleep(1)
            
            # Remove all temporary files and directories
            cleanup_commands = [
                "rm -rf temp_clone* || true",
                "rm -rf *.zip || true", 
                "rm -rf .git/objects/pack/tmp_* || true",
                "find . -name '*.tmp' -delete || true",
                "find . -name 'core.*' -delete || true"
            ]
            
            for cmd in cleanup_commands:
                subprocess.run(cmd, shell=True, capture_output=True)
                time.sleep(0.2)
            
            # Force garbage collection
            import gc
            gc.collect()
            
            return True
        
        def check_resources():
            """Check system resources"""
            try:
                # Check disk space
                df_result = subprocess.run(['df', '-h', '.'], capture_output=True, text=True)
                if df_result.returncode == 0:
                    lines = df_result.stdout.strip().split('\n')
                    if len(lines) > 1:
                        fields = lines[1].split()
                        if len(fields) >= 4:
                            print(f"üíæ Disk: {fields[3]} available ({fields[4]} used)")
                
                # Check memory
                free_result = subprocess.run(['free', '-h'], capture_output=True, text=True)
                if free_result.returncode == 0:
                    lines = free_result.stdout.strip().split('\n')
                    if len(lines) > 1:
                        fields = lines[1].split()
                        if len(fields) >= 3:
                            print(f"üß† Memory: {fields[6] if len(fields) > 6 else fields[3]} available")
                            
            except Exception as e:
                print(f"Resource check failed: {e}")
        
        def process_single_submodule(submodule, index, total):
            """Process a single submodule with full isolation"""
            print(f"\n{'='*80}")
            print(f"üöÄ PROCESSING {index}/{total}: {submodule['name']}")
            print(f"üìç URL: {submodule['url']}")
            print(f"üìÅ Folder: {submodule['folder']}")
            print(f"{'='*80}")
            
            # Pre-process cleanup
            aggressive_cleanup()
            check_resources()
            
            # Extract repo name from URL
            parsed_url = urlparse(submodule['url'])
            repo_name = os.path.basename(parsed_url.path).replace('.git', '')
            
            # Use unique clone directory for this process
            clone_dir = f"temp_clone_{index}_{int(time.time())}"
            branch = submodule.get('branch', 'main')
            
            try:
                print(f"üì• Step 1: Cloning repository...")
                
                # Ensure clean state
                if os.path.exists(clone_dir):
                    shutil.rmtree(clone_dir, ignore_errors=True)
                    time.sleep(0.5)
                
                # Build clone command with timeout
                if 'branch' in submodule:
                    clone_cmd = [
                        'timeout', '300',  # 5 minute timeout
                        'git', 'clone', 
                        '--depth', '1', 
                        '--single-branch', 
                        '--branch', branch,
                        '--config', 'core.longpaths=true',
                        submodule['url'], 
                        clone_dir
                    ]
                else:
                    clone_cmd = [
                        'timeout', '300',  # 5 minute timeout
                        'git', 'clone', 
                        '--depth', '1', 
                        '--single-branch',
                        '--config', 'core.longpaths=true', 
                        submodule['url'], 
                        clone_dir
                    ]
                
                print(f"   Command: {' '.join(clone_cmd)}")
                result = subprocess.run(clone_cmd, capture_output=True, text=True, timeout=320)
                
                if result.returncode != 0:
                    print(f"‚ùå Clone failed: {result.stderr}")
                    return False
                
                print(f"‚úÖ Clone successful")
                
                print(f"üì¶ Step 2: Creating zip file...")
                
                # Create target directory
                target_dir = f"Zipped-Code/{submodule['folder']}"
                os.makedirs(target_dir, exist_ok=True)
                
                # Remove .git directory immediately to save space
                git_dir = os.path.join(clone_dir, '.git')
                if os.path.exists(git_dir):
                    shutil.rmtree(git_dir, ignore_errors=True)
                
                # Create zip file with compression
                zip_filename = f"{repo_name}.zip"
                zip_path = os.path.join(target_dir, zip_filename)
                
                # Use Python's zipfile for better control
                import zipfile
                
                with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED, compresslevel=6) as zipf:
                    for root, dirs, files in os.walk(clone_dir):
                        for file in files:
                            file_path = os.path.join(root, file)
                            arcname = os.path.relpath(file_path, clone_dir)
                            zipf.write(file_path, arcname)
                
                if os.path.exists(zip_path):
                    size = os.path.getsize(zip_path)
                    print(f"‚úÖ Zip created: {zip_path} ({size / (1024*1024):.2f} MB)")
                else:
                    print(f"‚ùå Zip creation failed")
                    return False
                
                return True
                
            except subprocess.TimeoutExpired:
                print(f"‚è∞ Timeout occurred while processing {submodule['name']}")
                return False
            except Exception as e:
                print(f"‚ùå Error: {str(e)}")
                return False
            finally:
                print(f"üßπ Step 3: Cleanup...")
                # Always cleanup, even on failure
                if os.path.exists(clone_dir):
                    shutil.rmtree(clone_dir, ignore_errors=True)
                aggressive_cleanup()
                print(f"‚úÖ Cleanup completed")
        
        # Main execution
        try:
            print("üéØ Starting submodule processing...")
            
            # Parse submodules
            submodules = parse_submodules('Zipped-Code/submodules.txt')
            unique_submodules = get_unique_submodules(submodules)
            
            print(f"üìä Found {len(unique_submodules)} unique submodules to process")
            check_resources()
            
            # Initial cleanup
            aggressive_cleanup()
            
            # Process each submodule individually
            successful = 0
            failed = 0
            
            for i, submodule in enumerate(unique_submodules, 1):
                success = process_single_submodule(submodule, i, len(unique_submodules))
                
                if success:
                    successful += 1
                    print(f"‚úÖ SUCCESS: {submodule['name']}")
                else:
                    failed += 1
                    print(f"‚ùå FAILED: {submodule['name']}")
                
                # Progress update
                print(f"üìà Progress: {i}/{len(unique_submodules)} ({successful} successful, {failed} failed)")
                
                # Brief pause between submodules
                if i < len(unique_submodules):
                    print("‚è∏Ô∏è  Brief pause before next submodule...")
                    time.sleep(2)
            
            print(f"\n{'='*80}")
            print(f"üéâ PROCESSING COMPLETE!")
            print(f"‚úÖ Successful: {successful}")
            print(f"‚ùå Failed: {failed}")
            print(f"üìä Total: {len(unique_submodules)}")
            print(f"{'='*80}")
            
            # Final resource check
            check_resources()
            
        except Exception as e:
            print(f"üí• Fatal error: {str(e)}")
            sys.exit(1)
        
        EOF
    
    - name: Commit and push zipped files
      run: |
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Add all new zip files
        git add Zipped-Code/
        
        # Check if there are changes to commit
        if git diff --staged --quiet; then
          echo "No changes to commit"
        else
          git commit -m "Add zipped submodules [skip ci]"
          git push
        fi
