name: Zip Submodules

on:
  workflow_dispatch:
  push:
    branches: [ main ]
    paths:
      - 'Zipped-Code/submodules.txt'

jobs:
  zip-submodules:
    runs-on: ubuntu-latest
    timeout-minutes: 360  # 6 hours timeout
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        fetch-depth: 0
    
    - name: Setup Python
      uses: actions/setup-python@v4
      with:
        python-version: '3.x'
    
    - name: Setup Git LFS and configuration
      run: |
        # Install and setup Git LFS
        git lfs install
        
        # Configure Git LFS to track zip files over 50MB
        git lfs track "*.zip"
        git lfs track "Zipped-Code/**/*.zip"
        
        # Add .gitattributes if it doesn't exist or update it
        git add .gitattributes || true
        
        # Setup Git configuration
        git config --local user.email "action@github.com"
        git config --local user.name "GitHub Action"
        
        # Commit .gitattributes if there are changes
        if ! git diff --staged --quiet; then
          git commit -m "Setup Git LFS for zip files [skip ci]"
          git push origin HEAD
        fi

    - name: Parse submodules and create zip files
      run: |
        import os
        import subprocess
        import zipfile
        import time
        import shutil
        from pathlib import Path
        
        def check_resources():
            """Get current system resource usage"""
            disk_usage = shutil.disk_usage('/')
            disk_free_gb = disk_usage.free // (1024**3)
            disk_used_percent = (disk_usage.used / disk_usage.total) * 100
            
            return disk_free_gb, disk_used_percent
        
        def aggressive_cleanup():
            """Perform aggressive cleanup of temporary files and processes"""
            print("üßπ Performing aggressive cleanup...")
            
            # Kill any lingering git processes
            try:
                subprocess.run(['pkill', '-f', 'git'], capture_output=True, timeout=10)
            except:
                pass
            
            # Clean up temporary directories
            temp_dirs = ['/tmp', '/var/tmp']
            for temp_dir in temp_dirs:
                if os.path.exists(temp_dir):
                    try:
                        for item in os.listdir(temp_dir):
                            item_path = os.path.join(temp_dir, item)
                            if os.path.isdir(item_path) and ('git' in item.lower() or 'clone' in item.lower()):
                                shutil.rmtree(item_path, ignore_errors=True)
                    except:
                        pass
            
            # Force garbage collection
            try:
                subprocess.run(['python3', '-c', 'import gc; gc.collect()'], 
                             timeout=10, capture_output=True)
            except:
                pass
            
            # Clear system caches if possible
            try:
                subprocess.run(['sync'], timeout=10, capture_output=True)
            except:
                pass
        
        def clone_with_fallback(url, clone_dir, preferred_branch=None, timeout=300):
            """Clone repository with branch fallback logic"""
            print(f"üì• Step 1: Cloning repository...")
            
            # Clean up any existing directory
            if os.path.exists(clone_dir):
                shutil.rmtree(clone_dir, ignore_errors=True)
            
            # Try preferred branch first
            if preferred_branch:
                print(f"    Trying preferred branch: {preferred_branch}")
                try:
                    result = subprocess.run([
                        'git', 'clone', '--depth=1', '--single-branch', 
                        '--branch', preferred_branch, url, clone_dir
                    ], timeout=timeout, capture_output=True, text=True)
                    
                    if result.returncode == 0:
                        print(f"‚úÖ Clone successful using branch: {preferred_branch}")
                        return preferred_branch
                    else:
                        print(f"    ‚ö†Ô∏è  Branch '{preferred_branch}' not found, trying fallback...")
                except subprocess.TimeoutExpired:
                    print(f"    ‚ö†Ô∏è  Timeout cloning branch '{preferred_branch}', trying fallback...")
                except Exception as e:
                    print(f"    ‚ö†Ô∏è  Error cloning branch '{preferred_branch}': {e}")
            
            # Clean up failed attempt
            if os.path.exists(clone_dir):
                shutil.rmtree(clone_dir, ignore_errors=True)
            
            # Try to find default branch
            print(f"    üîç Finding default branch...")
            try:
                result = subprocess.run([
                    'git', 'ls-remote', '--symref', url, 'HEAD'
                ], timeout=60, capture_output=True, text=True)
                
                if result.returncode == 0:
                    lines = result.stdout.strip().split('\n')
                    for line in lines:
                        if line.startswith('ref: refs/heads/'):
                            default_branch = line.split('/')[-1]
                            print(f"    üìç Default branch detected: {line.split('/')[-1]}")
                            break
                    else:
                        # Fallback to common branch names
                        for branch in ['main', 'master', 'develop']:
                            try:
                                result = subprocess.run([
                                    'git', 'ls-remote', url, f'refs/heads/{branch}'
                                ], timeout=30, capture_output=True, text=True)
                                if result.returncode == 0 and result.stdout.strip():
                                    default_branch = branch
                                    print(f"    üìç Found branch: {branch}")
                                    break
                            except:
                                continue
                        else:
                            default_branch = None
            except:
                default_branch = None
            
            # Try clone without branch specification (gets default)
            print(f"    üîÑ Trying clone without branch specification...")
            try:
                result = subprocess.run([
                    'git', 'clone', '--depth=1', url, clone_dir
                ], timeout=timeout, capture_output=True, text=True)
                
                if result.returncode == 0:
                    print(f"    ‚úÖ Successfully cloned without branch specification")
                    print(f"‚úÖ Clone successful using branch: default")
                    return "default"
                else:
                    print(f"    ‚ùå Failed to clone: {result.stderr}")
                    return None
            except subprocess.TimeoutExpired:
                print(f"    ‚ùå Timeout during clone")
                return None
            except Exception as e:
                print(f"    ‚ùå Error during clone: {e}")
                return None
        
        def create_zip_file(source_dir, zip_path):
            """Create zip file from directory"""
            print(f"üì¶ Step 2: Creating zip file...")
            
            os.makedirs(os.path.dirname(zip_path), exist_ok=True)
            
            with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED, compresslevel=6) as zipf:
                for root, dirs, files in os.walk(source_dir):
                    # Skip .git directories to reduce size
                    if '.git' in dirs:
                        dirs.remove('.git')
                    
                    for file in files:
                        file_path = os.path.join(root, file)
                        arcname = os.path.relpath(file_path, source_dir)
                        try:
                            zipf.write(file_path, arcname)
                        except Exception as e:
                            print(f"    ‚ö†Ô∏è  Warning: Could not add {file_path}: {e}")
            
            # Get file size
            size_mb = os.path.getsize(zip_path) / (1024 * 1024)
            print(f"‚úÖ Zip created: {zip_path} ({size_mb:.2f} MB)")
            return size_mb
        
        def commit_and_push_file(file_path, repo_name, progress_info):
            """Commit and push a single file"""
            print(f"üì§ Step 4: Committing and pushing zip file...")
            
            try:
                # Get file size for logging
                size_mb = os.path.getsize(file_path) / (1024 * 1024)
                print(f"    üìè File size: {size_mb:.2f} MB")
                
                # Add the file
                subprocess.run(['git', 'add', file_path], check=True, capture_output=True)
                
                # Commit with descriptive message
                commit_msg = f"Add {repo_name} zip file - {progress_info} [skip ci]"
                subprocess.run(['git', 'commit', '-m', commit_msg], check=True, capture_output=True)
                
                # Push with default token
                print(f"    üöÄ Pushing to remote...")
                result = subprocess.run(['git', 'push', 'origin', 'HEAD'], 
                                      capture_output=True, text=True, timeout=120)
                
                if result.returncode == 0:
                    print(f"‚úÖ Successfully pushed {repo_name}")
                    return True
                else:
                    print(f"    ‚ö†Ô∏è  Failed to push: {result.stderr}")
                    return False
                    
            except subprocess.CalledProcessError as e:
                print(f"    ‚ö†Ô∏è  Git operation failed: {e}")
                return False
            except subprocess.TimeoutExpired:
                print(f"    ‚ö†Ô∏è  Push timeout")
                return False
            except Exception as e:
                print(f"    ‚ö†Ô∏è  Unexpected error: {e}")
                return False
        
        # Main processing logic
        submodules_file = "Zipped-Code/submodules.txt"
        
        if not os.path.exists(submodules_file):
            print(f"‚ùå Error: {submodules_file} not found!")
            print(f"üìÇ Current directory: {os.getcwd()}")
            print(f"üìÅ Directory contents: {os.listdir('.')}")
            if os.path.exists("Zipped-Code"):
                print(f"üìÅ Zipped-Code contents: {os.listdir('Zipped-Code')}")
            exit(1)
        
        # Parse .gitmodules format
        submodules = []
        current_submodule = {}
        
        with open(submodules_file, 'r') as f:
            for line in f:
                line = line.strip()
                if not line or line.startswith('#'):
                    continue
                
                if line.startswith('[submodule '):
                    # Save previous submodule if it exists
                    if current_submodule and 'path' in current_submodule and 'url' in current_submodule:
                        submodules.append(current_submodule.copy())
                    
                    # Start new submodule
                    current_submodule = {}
                    # Extract name from [submodule "name"]
                    name = line.split('"')[1] if '"' in line else line.split()[1].strip('[]')
                    current_submodule['name'] = name
                
                elif '=' in line and current_submodule:
                    key, value = line.split('=', 1)
                    key = key.strip()
                    value = value.strip()
                    current_submodule[key] = value
        
        # Don't forget the last submodule
        if current_submodule and 'path' in current_submodule and 'url' in current_submodule:
            submodules.append(current_submodule)
        
        # Filter out relative URLs and create unique submodules dict
        unique_submodules = {}
        for submodule in submodules:
            url = submodule['url']
            
            # Skip relative URLs
            if not url.startswith(('http://', 'https://', 'git://')):
                print(f"‚è≠Ô∏è  Skipping relative URL: {url}")
                continue
            
            # Extract repository name from URL
            repo_name = url.rstrip('/').split('/')[-1]
            if repo_name.endswith('.git'):
                repo_name = repo_name[:-4]
            
            # Use URL as key to avoid duplicates
            if url not in unique_submodules:
                unique_submodules[url] = {
                    'name': submodule['name'],
                    'path': submodule['path'],
                    'url': url,
                    'branch': submodule.get('branch'),
                    'folder': submodule.get('Folder', submodule['path']),
                    'repo_name': repo_name
                }
        
        total_submodules = len(unique_submodules)
        print(f"üìä Found {total_submodules} unique submodules to process")
        
        # Initial resource check
        disk_free, disk_used_pct = check_resources()
        print(f"üíæ Available disk space: {disk_free} GB ({disk_used_pct:.0f}% used)")
        
        # Process each submodule
        successful_count = 0
        failed_count = 0
        skipped_count = 0
        
        for i, (url, info) in enumerate(unique_submodules.items(), 1):
            print(f"\n{'='*60}")
            print(f"üîÑ Processing submodule {i}/{total_submodules}: {info['name']}")
            print(f"üìÇ Path: {info['path']}")
            print(f"üåê URL: {url}")
            if info['branch']:
                print(f"üåø Branch: {info['branch']}")
            print(f"üìÅ Folder: {info['folder']}")
            print(f"{'='*60}")
            
            # Resource check
            disk_free, disk_used_pct = check_resources()
            print(f"üíæ Available disk space: {disk_free:.1f} GB")
            
            # Create zip file path using the Folder field
            zip_path = f"Zipped-Code/{info['folder']}/{info['repo_name']}.zip"
            
            # **KEY FIX: Check if zip file already exists**
            if os.path.exists(zip_path):
                print(f"‚è≠Ô∏è  Zip file already exists, skipping: {zip_path}")
                skipped_count += 1
                continue
            
            # Check if we have enough resources
            if disk_free < 2:  # Less than 2GB free
                print(f"‚ö†Ô∏è  Warning: Low disk space ({disk_free:.1f}G), performing cleanup...")
                aggressive_cleanup()
                time.sleep(5)
            
            # Create unique temporary directory for this submodule
            temp_clone_dir = f"/tmp/clone_{i}_{int(time.time())}"
            
            try:
                # Clone repository
                branch_used = clone_with_fallback(info['url'], temp_clone_dir, info['branch'])
                
                if branch_used is None:
                    print(f"‚ùå FAILED: {info['name']} - Clone failed")
                    failed_count += 1
                    continue
                
                # Create zip file
                size_mb = create_zip_file(temp_clone_dir, zip_path)
                
                # Cleanup temporary clone directory immediately
                print(f"üßπ Step 3: Cleanup temporary files...")
                if os.path.exists(temp_clone_dir):
                    shutil.rmtree(temp_clone_dir, ignore_errors=True)
                
                # Additional aggressive cleanup
                aggressive_cleanup()
                
                # Commit and push the zip file
                progress_info = f"Progress {i}/{total_submodules}"
                push_success = commit_and_push_file(zip_path, info['repo_name'], progress_info)
                
                if not push_success:
                    print(f"‚ö†Ô∏è  Warning: Failed to commit/push, but zip file was created")
                
                print(f"üßπ Final cleanup...")
                aggressive_cleanup()
                
                print(f"‚úÖ SUCCESS: {info['name']}")
                successful_count += 1
                
            except Exception as e:
                print(f"‚ùå FAILED: {info['name']} - {str(e)}")
                failed_count += 1
                
                # Cleanup on failure
                if os.path.exists(temp_clone_dir):
                    shutil.rmtree(temp_clone_dir, ignore_errors=True)
                aggressive_cleanup()
            
            # Brief pause between submodules to prevent overwhelming the system
            if i < total_submodules:
                print(f"‚è∏Ô∏è  Brief pause before next submodule...")
                time.sleep(2)
        
        # Final summary
        print(f"\n{'='*60}")
        print(f"üìä PROCESSING SUMMARY")
        print(f"{'='*60}")
        print(f"‚úÖ Successful: {successful_count}")
        print(f"‚è≠Ô∏è  Skipped: {skipped_count}")
        print(f"‚ùå Failed: {failed_count}")
        print(f"üìã Total: {total_submodules}")
        print(f"{'='*60}")
        
        # Final cleanup
        aggressive_cleanup()
        
        # Exit with error code if there were failures
        if failed_count > 0:
            print(f"‚ö†Ô∏è  Some submodules failed to process. Check the logs above for details.")
            exit(1)
        
      shell: python

    - name: Final commit and push
      run: |
        echo "============================================================"
        echo "üì§ Final commit and push..."
        echo "============================================================"
        
        # Add any remaining files
        git add .
        
        # Check if there are any changes to commit
        if ! git diff --staged --quiet; then
          git commit -m "Final batch of zipped submodules [skip ci]"
          git push origin HEAD
          echo "‚úÖ Final commit pushed successfully"
        else
          echo "‚ÑπÔ∏è  No additional changes to commit"
        fi
